GCC的C编译器以汇编代码生成机器码，在assembler和linker的帮助下生成可执行机器码。本章将介绍机器码并以人类可读的汇编码形式展现。汇编代码是机器限定的，而高级语言可以编译被执行在多种机器上。

我们必须了解典型编译器在将C的结构转换为机器代码时所做的转换。相对于C代码中表达的计算，优化编译器可以重新排列执行顺序，消除不需要的计算，用更快的操作替换慢操作，甚至将递归计算更改为迭代计算。

这一章机器基于x86，我们将重点介绍 gcc 和 Linux 使用的功能子集。这使我们能够避免x86-64的许多复杂性和许多神秘功能。

32位计算机只能使用随机访问内存的$2^{32}$字节，而64位计算机可以使用$2^{48}$字节，并可以使用$2^{64}$字节的内存。

# 3.1 历史视角

我们使用实现处理器所需的晶体管数量来指示它们的复杂性是如何演变的。到2013年的因特尔i7，晶体管数目已经达到了1.4G个。

AMD在2002年左右变得更具竞争力，成为第一个打破商用微处理器1千兆赫时钟速度障碍的公司。

# 3.2 程序编码

gcc是Linux默认的编译器，-0g让编译器应用优化产出机器码，就程序性能来说，-01和-02是更高级别的优化。

gcc将程序源代码转为可执行文件。首先，C预处理将源代码扩大，把头文件和宏定义增加到文件里。第二，编译器生成汇编代码为p1.s和p2.s，第三，汇编器将汇编代码转为二进制对象文件p1.0和p2.0，二进制对象文件是机器码的一种。最后，连接器将两个对象文件和库函数进行合并，产生最后的可执行文件。可执行代码是机器码的第二种形式，也是处理器执行的形式。

## 3.2.1 机器级别代码

首先，机器级别程序的格式和行为由指令集定义，指令集定义了处理器状态，指令形式和指令意义。其次，机器级别程序使用的内存地址是虚拟地址，内存系统的实际实现涉及多个硬件存储器和操作系统软件的组合，如第9章所述。

X86-64的机器码和C代码有很大不同，部分处理器状态对C是隐藏的，而对机器码是可见的。

1. 程序计数器在x86-64称为%rip
2. 整数寄存器文件包含了16个命名的位置，每个位置存放64比特的值，这些寄存器保存地址和数据。
3. 一组向量寄存器可以分别保存一个或多个整数或浮点值。
4. 条件码寄存器保留了最近执行的状态信息，这些用于在控件或数据流中实现交互更改，例如实现 if 和 while 语句所需的更改。

C 中的聚合数据类型（如数组和结构）在机器代码中表示为连续的字节集合。即使对于标量数据类型，汇编代码也不会区分有符号整数或无符号整数、不同类型的指针，甚至不区分指针和整数。

程序内存包含程序的可执行机器码、操作系统所需的一些信息、用于管理过程调用和返回的运行时的栈，以及用户分配的内存块（malloc库函数）。如前所述，程序存储器使用虚拟地址进行寻址。在任何给定时间，只有虚拟地址的有限子范围被视为有效。例如，x86-64 虚拟地址由 64 位字表示。在这些机器的当前实现中，必须将上面的 16 位设置为零，因此地址可以指定 $2^{48}$ 或 64 TB 范围内的字节。操作系统负责将虚拟地址转为真实地址。

## 3.2.2 代码示例

对mstore.c使用gcc -Og -S mstore.c，gcc生成汇编文件mstore.s。

每一行都代表一个机器指令，如pushq指令显示了寄存器%rbx的内容应该被添加到程序栈里，所有数据类型和局部变量等数据都被去除了。

如果使用**gcc -Og -c mstore.c**，gcc不仅编译还将汇编成对象文件mstore.o，它是二进制形式但是无法被直接查看。为了检查机器码的内容，一类名为反汇编的程序起到了作用，例如objdump -d mstore.o。

查看输出可以看到14个十六进制字节值，以1-5个字节为分组，每个分组都是一个单独指令，相应的汇编代码如右边所示。这里有几个机器码和反汇编表示之间需要关注的地方：

1. X86-64指令长度在1到15字节，越常用的操作一般字节编码越短。
2. 以给定开始位置设置指令格式可以让字节码唯一解码为某个机器指令。
3. 反汇编程序基于机器码的字节序列给出汇编代码，它不需要获得源文件或者程序的汇编版本。
4. 和gcc生成的汇编代码相比，反汇编程序使用一个稍微不同的命名规则去编码指令。例如在例子里反汇编程序会增加q后缀给call和ret指令。

生成实际可执行文件需要在众多对象代码文件里运行连接器，其中一个代码文件必须包含main函数。假设main.c包含了主函数，然后使用**gcc -Og -o prog main.c mstore.c**生成可执行文件prog，prog不仅包含需要执行的机器码还包含了OS交互的用于开始和中止程序的代码。使用**objdump -d prog**进行反汇编，生成的代码和mtsore.c的反汇编代码几乎一致，第一个区别是指令地址不同，连接器已经将代码位置转移到了不同的地址。第二个区别是连接器已经设置好了callp指令调用mult2函数的地址。最后一个区别在于第八行和第九行，他们在return后出现，对程序没有影响，插入它们是为了将函数的代码增加到16个字节，从而在内存系统性能方面更好地放置下一个代码块。

## 3.2.3 格式标注

gcc生成的汇编代码人类很难懂，一方面包含了不需要的信息另一方面并不给程序如何运行的描述。使用**gcc -Og -S mstore.c**命令生成mstore.s，文件内容里所有的行都以.开头，用于指导编译器和连接器，可直接忽略。

为了提供一个清楚的汇编代码表示，将以省略大多数指令的形式显示它，同时包括行号和解释性注释，一个标注的版本在书中也给出。

开发者可以使用汇编语言访问机器底层代码，一个方法是以汇编代码写下整个函数并结合他们和C语言，另一个代码是使用gcc直接将汇编代码和C程序连接在一起。

# 3.3 数据格式

由于16比特到32比特的进步，因特尔使用字去表示16比特数据类型，双字为32比特，四字为64比特，图3.1给出了x86-64表示C数据类型。

如图3.1显示，GCC生成的大多数汇编指令都有单个字符后缀标记操作的大小，例如movb，movw和movl。汇编代码使用后缀"l"来表示 4 字节整数以及 8 字节双精度浮点数。这不会造成歧义，因为浮点代码涉及一组完全不同的指令和寄存器。

# 3.4 访问信息

x86-64CPU包含16个通用寄存器去存储64比特的值，这些寄存器被用于存放整数和指针。图3.2给出了16个寄存器，以%r开头，原始的8086有8个16比特寄存器，开头为%ax和%bx，IA32将寄存器拓展到32比特寄存器，并命名为%eax和%ebp，在x86-64里，原始的八个寄存器被拓展为64比特，以%rax和%rbp命名，另外增加了8个新的寄存器从%8到%15。

在后面的部分中，我们将提供一些有关复制和生成 1、2、4 和 8 字节值的说明。当这些指令将寄存器作为目标时，对于生成少于 8 个字节的指令，将出现两种约定：那些生成 1 字节或 2 字节数量的指令将保留剩余字节不变的指令。那些生成 4 字节数量的字节将寄存器的上限 4 个字节设置为零。后一项约定作为从IA32扩展到x86-64的一部分而获得通过。

如图3.2右边标记，不同的寄存器有不同的职责如堆栈指针 %rsp，用于指示运行时堆栈中的结束位置。一些指令专门用于%rsp的读写，而其他的15个寄存器使用更加灵活。

## 3.4.1 操作数

大多数指令都有一个或者多个操作数用于标记原始数据和目的数据，如图3.3所示，x86-64支持很多操作数形式。 原始值可以作为常量给出，也可以从寄存器或内存中读取。结果可以存储在寄存器或存储器中。将不同操作数分成三类：

1. 立即数：immeditae大类是常数，在ATT格式汇编代码，以$开头后面跟着一个数。
2. 寄存器值：register标记寄存器的值，使用$r_a$标记一个任意寄存器，并使用$R[r_a]$标记寄存器的值。
3. 内存值：第三类操作数是内存，为了访问有效地址，使用$M_b[Addr]$标记b比特的值，开头地址是Addr，为了简化往往丢弃b。

最常用的地址模型是$Imm(r_b,r_i,s)$，由四个部分组成，第一个是立即偏移Imm，一个基寄存器$r_b$，一个索引寄存器$r_i$，一个比例因子s，s取1，2，4，8。两个寄存器必须是64比特的，有效的地址被标记为$Imm+R[r_b]+R[r_i]*s$，

## 3.4.2 数据移动指令

最常用的指令是从一个地方复制到另一个地方，我们提供了许多不同的数据移动指令，不同源和目标类型，它们执行的转换以及它们可能产生的其他副作用都不同。将很多不同的指令归类为指令类，某个类的指令运行相同的操作数但是不同的操作数大小。

图3.4给出了最简单的数据移动操作即mov类，这个类有4个指令movb，movw，movl和movq，所有的指令都有相同功能但是区别于数据大小不同（1 2 4 8比特）。

原始操作数指定一个即使数，它存储在寄存器中，或存储在内存中。目的操作数的位置要么是寄存器要么是内存地址，x86-64限制了一个移动指令无法在内存里进行数的移动，完成它必须通过寄存器作为中间商进行处理。在大多数情况下，mov 指令将仅更新目标操作数指示的特定寄存器字节或内存位置。唯一例外是movl指令以寄存器作为目的地址，它还会将寄存器的高阶 4 字节设置为 0。此例外源于 x86-64 中采用的约定，即为寄存器生成 32 位值的任何指令也会将寄存器的高阶部分设置为 0。

图3.4最后的指令用于处理64位的立即数，常规movq只能操作32比特的立即数作为源操作数，movabsq指令可以有任意64比特的值作为源操作数但只能是寄存器作为目的地址。

图3.5和3.6给出了两类数据移动指令，用于当复制小源操作数到更大的地址，这些指令用于从寄存器或内存里复制数据到寄存器里。movz类的指令将以0补充开头的字节，movs类以符号位进行补充，指令只包含目的地址大于源地址的情况。

要注意的是，图 3.5 中没有将 4 字节零扩展到 8 字节目标的指令。这样的指令在逻辑上被命名为movzlq，但这个指令并不存在。这种类型的数据移动可以使用具有寄存器作为目标的移动指令来实现。即生成带有寄存器作为目标的 4 字节值的指令将用零填充上面的 4 个字节。对于 64 位机器，所有三种源类型都支持使用符号扩展进行移动，而对于两种较小的源数据类型，仅支持使用零扩展名移动。

图3.6给出了cltq指令，无操作数，总是使用%eax为原地址和%rax为目的地址。

## 3.4.3 数据移动例子

考虑图3.7的数据交换，这里的C代码和汇编代码都是gcc生成的。如图3.7b所示，exchange函数由三条指令实现，即两个movq和一个ret，一个函数返回一个值是通过将值存在%rax实现的，或者是某个低次序的寄存器。

一开始xp和y被存放在寄存器%rdi和%rsi里，指令2从内存里读取x并存储在%rax里，指令3将y写入到%rdi里存档的xp的内存位置里。第二行代表了mov指令如何从内存写入到寄存器里，第三行代表如何从寄存器写入到内存里。关于汇编代码的两个特征需要注意，第一是C的指针代表地址，解除指针引用如*x等同将指针复制到寄存器，然后使用寄存器在内存的引用，即寄存器指向地址对应的值。第二，局部变量如x通常存放在寄存器里而不是内存位置。

## 3.4.4 入栈和出栈

最后两个程序用于在程序栈里推送数据和弹出数据，在x86-64里，程序栈存放于内存的某个区域，如图3.9所示，栈总是向下生长，栈顶拥有所有元素的最低地址，栈指针%rsp存放了栈顶元素地址。

pushq和popq代表从栈存放一个元素和弹出一个元素，往栈添加一个四字元素首先需要减少栈指针8字节，然后将元素写入到新栈顶地址里。

pushq %rbp = sub $8,%rsp和mov %rbp (%rsp)，注意pushq指令是单字节机器码。

popq %rax = movq (%rsp) %rax + addii $8 %rsp，同样也是单字节指令，这先从栈顶获得元素，存入%rax里，然后将栈顶增加8字节，这里原始的数据会保留直到被覆盖。

# 3.5 计算和逻辑操作

图3.10给出了x86-64整数和逻辑运算，主要介绍了加载有效地址，unary，binary和shifts四组操作。

## 3.5.1 加载有效地址

leap实际上是movq的一个变种，它是从内存读到寄存器的指令，但是它不涉及内存引用，它的第一个操作数似乎是一个内存引用，但是该指令不是从指定的位置读取，而是将有效地址复制到目的地。如果寄存器%rdx包含了值x，那么指令leap 7(%rdx,%rdx,4),%rax将最终让%rax等于5x+7。

## 3.5.2 unary和binary操作

unary使用单个操作数既作为原地址也作为目的地址，这个操作数要么是一个寄存器，要么是一个内存地址。

binary操作里第一个数既是原地址也是目的地址，类似于x-=y，第一个操作数可以是一个即时值，一个寄存器，或一个内存位置。第二个操作数可以是一个寄存器或一个内存位置。与mov指令一样，两个操作数不能都是内存位置。注意，当第二个操作数是一个内存位置时，处理器必须从内存中读取数值，执行操作，然后将结果写回内存，subq %rax,%rdx将%rdx的值减去%rax。

## 3.5.3 移位操作

第一个操作数给出了移多少，第二个操作数给出了待移位的数，移位操作的不同在于移位数目数通过立即数还是通过单字节寄存器%cl给出的，在x86-64里，w bit的移位需要考虑%cl的m位，例如，如果寄存器%cl的值是FF，那么salb只移动7位，salw只移动15，sall只移动31，salq移动63。

针对左移操作，有SAL和SHL两个一样的指令，都从右边添加0。而右移操作SAR代表了算数右移，以符号位填充，SHR代表逻辑右移，以0进行填充。移位的目的操作数可以是寄存器或者内存地址。

## 3.5.4 讨论

我们看到，图3.10中的大部分指令都可以用于无符号或二进制补码的运算。只有右移需要区分有符号和无符号数据的指令。

图3.11给出了一个函数的例子，进行运算操作并转换为汇编代码的例子。

## 3.5.5 特殊运算操作

X86-64只给了很有限的支持去表示8字节之间的乘法，图3.12给出了支持生成128比特的乘法和除法。

imuq指令有两种形式，第一种如图3.10，属于imul指令类，从两个64位的操作数里生成64位的操作数，当缩减结果到64比特的时候，无符号乘法和二进制乘法都有一样的比特表示。此外，x86-64指令集包括两个不同的 "单操作数 "乘法指令，用于计算两个64位数值的全部128位乘积，一个用于无符号(mulq)，一个用于双补(imulq)乘法。对于这两条指令，一个参数必须在寄存器%rax中，另一个参数作为指令的源操作数给出。然后，结果被储存在寄存器%rdx（高阶64位）和%rax（低阶64位）。尽管imulq这个名字被用于两个不同的乘法运算，但汇编器可以通过计算操作数来判断哪一个是目的。

下面给出了两个无符号64比特乘积的例子，我们依赖gcc提供的128位的支持，使用名为__int128，代码使用typedef去定义新数据类型uint128_t，这是为了和inttypes.h里的数据类型保持一致。

从汇编生成的代码可以看出，存储结果需要两个movq指令，前面的算术运算表（图3.10）没有列出任何除法或模数运算。这些操作是由单操作数的除法指令提供的，与单操作数的乘法指令类似。有符号的除法指令idivl将寄存器%rdx（高阶64位）和%rax（低阶64位）中的128位作为被除数，除数作为指令的操作数。该指令将商储存在寄存器%rax中，将余数储存在寄存器%rdx中。

对大多数64位加法来说，被除数以64位给出，存放在rax里，rdx应该被设置为全0（无符号数）和rax的符号位（有符号运算），后面的操作使用cqto完成，他没有操作数，而是将rax符号位读取，然后复制填满rdx的每一位。

下面给出了x86-64里除法的实现，在其汇编代码里，rp必须首先在一个不同寄存器里保留，这是因为rdx对除法运算是必须使用的，第3-4行用于准备被除数，寄存器rax中的商被存储在qp（第6行），而寄存器rdx中的余数被存储在rp（第7行）。无符号除法使用了divq指令。通常情况下，寄存器%rdx被事先设置为零。

# 3.6 控制

机器代码提供了两个基本的底层机制来实现条件：它检查数据值，然后根据这些测试的结果改变控制流或数据流。数据依赖型控制流是实现条件行为的更普遍、更常见的方法，因此我们将首先研究这个方法。

一组机器代码指令的执行顺序可以通过跳转指令来改变，表明控制权应该转移到程序的其他部分，编译器必须在这种低级机制的基础上生成指令序列，以实现C语言的控制结构。我们首先介绍了实现条件操作的两种方法。然后我们描述了呈现循环和切换状态的方法。

## 3.6.1 条件码

除了整数寄存器之外，CPU还保留了一组单bit的条件代码寄存器，记录最近的算术或逻辑操作的属性，给出四个常用的：

1. CF，进位，最常用的操作数产生了一个最有效位的进位。因此CF用于检测无符号操作的溢出。
2. ZF，用于标记最近的操作是否产生了0。
3. SF，最近的操作是否产生了负数
4. OF，最近的操作是否造成了二进制补码的溢出。

leaq指令不改变任何条件码，除此之外图3.10的所有指令都会造成条件码更改。对于逻辑运算，例如XOR，进位和溢出位都被设置为0，对于移位，进位被设置为最后一位移出的，OF被设置为0。inc和dec指令设置了溢出和零标志，但它们没有改变进位标志。

还有两个指令类在不改变寄存器条件下设置了条件码，如图3.13的CMP指令去比较两个操作数，本质上和SUB指令一样，除了它去设置条件码而不是去更新结果。如果两个操作数相等，这些指令将设置零标志。其他的标志可以用来确定两个操作数之间的排序关系。测试指令的行为方式与and指令相同，只是它们设置条件代码而不改变其目的地。通常情况下，同一操作数会被重复使用（例如，testq %rax,%rax查看%rax是否为负数、零数或正数），或者其中一个操作数是一个掩码，表示哪些位应该被测试。

## 3.6.2 访问条件码

条件码不是直接读取，而是通过3种方式获得：1.根据一些条件码的结合去设置单个字节为0或者1。2.有条件地跳到程序其他部分。3.有条件地转移数据。

对于第一种情况，图3.14中描述的指令根据条件码的某些组合，将一个字节设置为0或1，我们把这一类指令称为设置指令。它们的不同之处在于它们考虑了哪些条件代码的组合，正如指令名称的不同后缀所表明的那样。重要的是要认识到，这些指令的后缀表示不同的条件，而不是不同的操作数。例如，指令setl和setb表示 "set less "和 "设置set below"，而不是 "set long word "或 "set byte"。

一个SET指令要么将寄存器的单字节低位作为目的地址，要么将单字节内存地址作为目的地址，设置这个字节要么是0要么是1。为了生成32和64比特结果，我们必须清理高地址比特，计算long a<long b的指令以以下方式进行。

注意cmpq的比较顺序，参数被列在rsi和rdi上，正如在第3.4.2节中所讨论的，movzbl指令（第4行）不仅清除了%eax的高阶3字节，还清除了整个寄存器%rax的高阶4字节。

使用SF^OF and ZF来实现a<b。无符号数字的比较使用ZF和CF。

注意机器代码是如何区分有符号和无符号的值的。与C语言不同的是，它没有将数据类型与每个程序值联系起来。相反，大多数情况下它对这两种情况使用相同的指令，因为许多算术操作对无符号和二进制补码有相同的位级行为。有些情况需要不同的指令来处理有符号和无符号运算，例如使用不同版本的右移、除法和乘法指令，以及不同的条件代码组合。

## 3.6.3 跳转指令

jump指令可以让程序跳转，其目的地在汇编代码里用label标记，在生成的对象文件里，编译器会记录所有标记指令的地址。图3.15给出了不同的跳转指令，只有jmp指令是无条件跳转，可以通过直接跳转如jmp .L1去跳转到L1部分，也可以通过寄存器和内存地址实现间接跳转，如jmp *%rax使用寄存器%rax的值作为跳转目标，jmp *(%rax)以%rax的值作为地址进行跳转。

## 3.6.4 跳转指令编码

在汇编代码中，跳转目标是用符号标签写的。汇编器，以及后来的链接器，都会产生适当的跳转目标的编码。有几种不同的跳转编码，但一些最常用的是PC相关编码。

它们编码的区别是目标指令的地址和紧接着跳转的指令的地址之间的差异。这些偏移量可以用1、2或4个字节进行编码。第二种编码方法是给出一个 "绝对 "地址，用4个字节来直接指定目标。汇编器和链接器针对跳转指令会选择适当编码。

下面给出了一个例子，由汇编器针对.o文件生成的反汇编如图所示，jump目标是0x8和0x5。可以看到，第一个jump指令目标是0x03，将其增加0x5(下一个指令的地址)，可以得到地址0x08，即第四行的目标指令。类似的，第二个跳转指令编码为0xf8，增加0xd(下一个指令的地址)后，得到地址0x5，即第三行的指令。

下面给出了链接后的反汇编版本，可以看到指令被重新定位到不同的地址，但是第2行和第5行的跳转目标的编码保持不变。使用PC相关编码，指令可以使用2字节进行编码。

## 3.6.5 用条件控制实现条件分支

最常用的将C语言的条件表达和陈述翻译为机器码的方法是使用条件和非跳转结合。图3.16a给出了计算两个数字绝对值的C语言实现，该函数修改全局变量It_cnt或ge_cnt，gcc生成的汇编代码如c所示，我们给出了程序的goto版本如图3.16b所示。

下面给出了汇编语言写if else的形式，和C语言是对应的。

## 3.6.6 用条件移动实现条件分支

实现条件操作通常的办法是通过控制的条件转移， 这种机制简单而通用，但在现代处理器上可能效率很低。

一个可代替的方法是通过数据的条件转移，方法计算条件操作的结果然后给予条件是否成立选择一个。这种策略只有在有限的情况下才有意义，但这时可以通过一个简单的条件性移动指令来实现，该指令与现代处理器的性能特征更加匹配。在这里，我们研究了这种策略和它在x86-64中的实现。

图3.17a给出了使用条件移动编译的代码，函数计算x和y的绝对值，这个例子仅计算了函数返回的值。针对这个函数，gcc给出了汇编代码如图3.17c所示，这和3.17b类似。它先计算了y-x和x-y，分别赋值给了rval和eval，然后检查x是否大于等于y，如果是则赋值eval到rval里。3.17c是类似的逻辑，关键是cmovge指令实现了图3.17b的功能，只有在第六行cmpq指令显示某个数大于等于另一个数的时候，它将数据从源寄存器转移到目的地。

为了理解为什么基于条件性数据传输的代码可以胜过基于条件性控制传输的代码，我们必须了解一些关于现代处理器的运作方式。正如我们在第4章和第5章中所看到的，处理器通过流水线来实现高性能，即通过一系列的阶段来处理一个指令，每个阶段执行所需操作的一小部分（例如，从内存中获取指令，确定指令类型，从内存中读取，执行算术运算，写入内存，以及更新PC）。这种方法通过重叠连续指令来实现高性能，例如，在获取一条指令的同时，执行前一条指令的算术运算。要做到这一点，需要能够提前确定要执行的指令的顺序，以便使流水线上充满要执行的指令。**当机器遇到条件性跳转时，在评估分支条件之前，它无法确定分支的走向。处理器采用复杂的分支预判逻辑，试图猜测每个跳转指令是否会被执行。只要它能可靠地猜测（现代微处理器设计试图达到90%的成功率）**，指令流水线就会一直充满指令。另一方面，预测错误的跳转需要处理器放弃它在未来指令上已经完成的大部分工作，然后开始用从正确位置开始的指令填充管道。正如我们将看到的，这样的错误预测会带来严重的惩罚，例如，浪费15-30个时钟周期的努力，造成程序性能的严重下降。

给出一个运行absdiff函数的例子，分别使用两种实现条件的方式。在常规应用里，x<y的结果是不可预测的，即使是最复杂的分支预测硬件也只能猜对50%左右的时间。此外，两个代码序列中的每一个所进行的计算只需要一个时钟周期。因此，分支预测错误的惩罚主导了这个函数的性能。对于带有条件跳转的x86-64代码，我们发现，当分支模式容易预测（预测对）时，该函数每次调用需要约8个时钟周期，而当分支模式是随机的时，每次调用需要约17.50个时钟周期。由此，我们可以推断，分支错误预测的惩罚大约是19个时钟周期。这意味着函数所需的时间大约在8到27个周期之间，这一时间取决于分支是否被正确预测。

另一方面，使用条件移动编译的代码需要大约8个时钟周期，无论测试的数据是什么。控制流不依赖于数据，这使得处理器更容易保持其流水线的完整。

图3.18展示了x86-64的条件移动指令，每个指令都有两个操作数，一个源寄存器或者内存位置S，一个目的寄存器R，源值从内存或源寄存器中读取，但只有当指定的条件成立时才会复制到目的地。

源值和目的值可以是16、32或64比特长。不支持单字节的条件性移动。与无条件指令不同的是，在无条件指令中，操作数的长度被明确地编码在指令名称中（如movw和movl）。而针对有条件移动，汇编器可以从目的寄存器的名称中推断出有条件移动指令的操作数长度，因此同一指令名称可以用于所有操作数长度。

为了理解条件操作如何通过条件数据转移视线，考虑接下来的三元表达式例子，条件性和非条件性跳转的组合被用来确保只有一个序列被检查。而对于基于条件移动来说，then-expr和else-expr都会被检查，最后给予test-expr来决定哪个值被选择。

并不是所有的条件表达式都可以使用条件移动编译，如果这两个表达式中的一个出现错误，这就可能导致无效的行为。我们之前的例子就是这样的（图3.16）。事实上，我们在这个例子中加入了副作用去迫使gcc使用条件转移来实现这个函数。

第二个例子考虑如下的C函数，这个例子可以使用条件移动来编译，当指针为空时，将结果设置为零，如以下汇编代码所示。实际上这个实现是无效的，因为movq指令在尝试找%rdi的内容时，就会发生错误，造成空指针解析引用错误，这个代码必须使用分支代码进行。

使用条件移动也不一定能提高代码效率。例如，如果then-expr或else-expr的检查需要大量的计算，那么当相应的条件不成立时，这些计算就被浪费了。编译器必须考虑到浪费的计算的相对性能与由于分支错误解释而导致的潜在性能损失。事实上，他们并没有足够的信息来可靠地做出这个决定；对gcc的实验表明，它只在两个表达式可以非常容易地被计算出来时才使用条件移动，例如，用单一的加法指令。根据我们的经验，即使在很多情况下，分支错误预测的代价会超过更复杂的计算，gcc也会使用条件控制转移。

总的来说，我们看到条件性数据传输为实现条件性操作提供了一种替代条件性控制转移的策略。它们虽然只能在有限的情况下使用，但这些情况是相当普遍的，并为现代处理器的操作提供了一个更好的匹配。**注意，使用条件移动实现需要进行额外的运算，而使用条件控制就不需要。**

## 3.6.7 循环

C语言实现了三种循环，底层使用条件测试和跳转指令来实现循环，gcc和其他编译器给予两种循环样式生成循环代码，首先学习do-while循环。

图3.19a给出了使用do-while循环计算n!的代码，3.19b给出了goto版本使用了条件跳转和测试结合的方式，图3.19c给出了goto生成的汇编代码，在逆向工程汇编代码后，需要确定哪个寄存器被用于存储程序值，这里使用%rdi存储n，%rax被初始化为1，我们可以看到寄存器在第四行进行了更新，%rax一般用于程序返回值，即这里的result。



给出while循环的结构，gcc使用两种方法将while循环翻译为机器码，第一种方法称为jump to middle，通过一个无条件跳转指令完成初始化测试，在完成条件判断后goto到循环体。

图3.20a给出了使用while循环实现的factorial函数的例子，图3.20b是当用命令行操作-Og指定优化时，gcc生成的汇编代码的C版本。和图3.19b相比，非常相似除了goto语句，图3.20c给出了生成的汇编代码。

第二种方法称为guarded do，首先将代码转为do-while循环，如果初始测试失败，通过使用条件分支来跳过循环。gcc用更高的优化水平编译时遵循这一策略，例如，用命令行选项-O1。下面给出了从while到do-while的例子，并和goto代码进行了对比，使用这样的方式，编译器可以优化初始测试如决定测试条件总是成立。

图3.21给出了和图3.20一样的代码，但是是gcc被赋予命令行选项-O1时发生的编译，图3.21c给出了汇编代码，图3.21b是汇编代码更可读的C形式，注意测试n!=1不等价于测试n<=1。我们可以发现编译器在使用guarded-do版本的时候使用了第三行的jle指令去跳过loop循环。



给出for循环的结构，根据优化等级，gcc生成的代码也遵循while循环的两种方式，即jump to middle和guarded-do策略。这里给出了使用-Og生成的汇编代码。

## 3.6.8 switch语句

switch语句基于整数值提供了多个分支，它们不仅使C代码更具可读性，而且还允许使用一种叫做跳转表的数据结构来有效地实现。跳转表是一个数组，其中第i项是实现程序在切换索引等于i时应采取的行动的代码段的地址，代码使用索引对跳转表进行数组引用，以确定跳转指令的目标。与一长串if-else语句相比，使用跳转表的好处是执行切换的时间与切换情况的数量无关。gcc根据情况的数量和值的范围来选择翻译switch语句的方法。当有若干个情况（例如，四个或更多），并且这些情况的数值跨度很小时，就会使用跳转表。

图3.22a给出了例子，给出的值并不连续，多个情况，没有break。图3.23给出了汇编代码，代码使用了跳表，数组jt包含了七个实体，每个都是某个代码块的地址，这些地址被标签标记，并在jt中的条目中用代码指针表示，由&&为前缀的标签组成。原始C代码给出了100，102-104，106的情况，编译器首先将范围减n限定为0到6，创建了在C中称为index的变量，在C和汇编代码中，根据index的值，有五个不同的位置可以跳转到，具体的可见图3.22。请注意，跳转表处理重复的情况时，只需将相同的代码标签（loc_D）作为条目4和6，它处理缺失的案例时，将默认案例的标签（loc_def）作为条目1和5。

下面给出了跳转表在汇编代码的实现，在被称为.rodata（代表 "只读数据"）的代码文件段中，应该有一个由7个 "四"（8字节）字组成的序列，每个字的值由指定的汇编代码标签（如.L3）相关的指令地址给出。标签.L4标志着这个分配的开始。与这个标签相关的地址作为间接跳转的基础（第5行），可以得出结论使用跳转表可以高效实现分支。

# 3.7 程序

程序(procedures)是软件的重要抽象，提供一种方式打包代码，函数然后会从程序的不同地方进行调用，程序在不同的编程语言中有多种表现形式--函数、方法、子程序、处理程序等，但它们都有一套通用的特征。考虑程序P调用程序Q，Q执行后返回给P，这样的动作涉及3个机制：

1. 传递控制，PC必须被设置Q的开始地址，在Q结束后设置P的指令。
2. 传递数据，P必须提供一到多个参数给Q，然后Q返回值给P。
3. 分配和回收内存，Q可能需要一些空间去存储局部变量并在结束后释放。

在后面我们将首先介绍控制，然后是数据传递最后是内存管理。

## 3.7.1 栈

P调用Q，可以看到在Q执行的时候，P被短暂暂停，一个程序可以使用堆栈来管理其程序所需的存储，堆栈和程序寄存器存储了传递控制和数据以及分配内存所需的信息。和3.4.4描述的一样，x86-64栈往低地址增加，%rsp指向了栈的最高元素，pushq和popq指令操作其中的元素。

当x86-64程序需要的存储超过寄存器的空间，需要分配栈上的空间。图3.25给出了栈的结构，当前执行的程序总是在栈顶，当P调用Q时，首先添加返回地址给栈上，即P应该在Q返回的时候继续执行，Q的代码通过拓展当前栈边界来获得栈空间，大多数程序的栈是固定大小的，在程序开始时分配。然而，有些程序需要可变大小的空间。程序P可以在栈中传递最多六个整数值（即指针和整数），但是如果Q需要更多的参数，这些参数可以在调用之前由P存储在其栈中。

## 3.7.2 控制转移

为了让Q返回后处理器必须知道从哪个位置继续P，通过调用call Q完成这一功能。该指令将地址A推入栈里并设置PC为Q的开始地址。地址A其实就是返回地址，放在call后面，和call对应的ret指令负责弹出地址A并将PC设置为A。

callq和retq是x86-64的返回指令，像jump指令一样，call可以是直接也可以是间接的，在汇编代码里，直接调用的目标由一个标签给出，间接调用的目标由*操作数给出。图3.26给出了call和ret指令的执行和，下面也给出了两个函数的反汇编代码。

在代码里，可以看到call 0x400563意为main调用multistore，状态见图3.26a，初始值是栈指针%rsp和程序计数器%rip，call的作用是将返回地址0x400568加入栈里并跳转到multstore的第一个指令，其位置在0x0400540。multstore函数的执行会一直继续直到碰到了返回地址0x40054d。retq会从堆栈中弹出数值0x400568并跳转到这个地址，在调用指令之后恢复了main的执行。

图3.27a展示了两个函数top和leaf的反汇编代码，以及main函数里调用top的部分。L1-L2是leaf指令，T1-T4是top指令，M1-M2是main指令。图3.27b展示了代码执行的细节，main调用了top，造成top调用了leaf，函数leaf返回了97给top，top返回194给main。图里的前三列描述了被执行的指令即指令标签，地址和指令类型。第4-7列给出了指令被执行前程序的状态（三个寄存器和栈顶指针）。

leaf的指令L1设置%rax为97，指令L2然后返回，弹出0x400054e并设置PC为这个值，控制转移到top的T3指令，程序已经成功完成调用leaf并返回给top。指令T3设置%rax为194，这个值由top返回来，指令T4然后返回，弹出0x4000560，即设置PC为main函数的M2，此时程序已经完成调用top并返回给main，我们也可以看到栈指针已经复原。

## 3.7.3 数据转移

除了控制的转移，程序调用可能涉及传递数据作为参数并返回值，在x86-64里，大多数数据转移发生在寄存器里，注意最多可以通过寄存器传递6个参数（整数和指针）。寄存器如图3.28所示，参数根据自己的顺序被分配给相应的寄存器，小于64比特的参数可以使用64bit的低位部分进行传参。

当函数需要超过6个参数的时候，超过的部分通过栈进行，假设P调用Q，传递的参数是n个，当n大于6的时候，P必须分配栈空间给多的参数，如图3.25所示。首先复制参数1-6到合适的寄存器里，然后将参数7放到栈顶，当在堆栈上传递参数时，所有的数据大小都被设置为8的倍数。在参数放置完毕后，程序可以执行call指令将控制权转移给Q，程序Q可以通过寄存器和栈访问参数，如果Q调用了某个超过6个参数的函数。考虑图3.29a里的C函数proc，有八个参数，其汇编代码见图3.29b所示。图3.30给出了函数执行的状态，两个多的参数在栈指针的第8和第16位，他们的下面才是返回地址。

## 3.7.4 栈的局部存储

有时候数据必须存储在内存，包括了如下三种情况：

1. 没有足够的寄存器去存储所有的数据。
2. &被应用于局部变量。
3. 数组和结构体作为参数的时候必须要以数组和结构体引用去访问。

通常情况下，程序通过递减堆栈指针来分配堆栈框架上的空间。这就对应了图3.25中堆栈框架里标记为 "local variable "的部分。

考虑图3.31a的两个函数，swap_add通过两个指针交换数值并返回他们的和，函数caller为本地变量arg1和arg2创造了指针并传递给swap_add。图3.31b给出了caller如何使用栈去存储这些本地变量。caller的代码从减栈指针16开始，这意味着栈分配了16个字节。S标记着栈指针，那么S+8就是arg2，S就是arg1，即这两个变量分别存储在偏移为0和8的位置。当调用swap_add的时候，caller会取回这两个值，计算他们的区别并乘以swap_add返回在%rax的值。最后caller函数会将栈指针增加16。

图3.32给出了一个更详细的例子，名为call_proc，图3.32b给出了汇编代码，可以看到2-15行都在为调用proc做准备。这包括了设置栈并加载函数参数到寄存器里，如图3.33所示，x1-x4都被分配到站且长度不同，这些地址的指针都是通过leaq指令执行的。

当proc被调用的时候，程序将从图3.29b开始执行代码，如图3.30所示，参数7和8的偏移量变成了8和16，这是因为返回地址被加入到堆栈的原因。

## 3.7.5 寄存器的局部存储

程序寄存器作为所有程序分享的资源被共享。我们必须确保当caller调用callee的时候，callee不会覆盖caller使用的寄存器值，出于这个目的，x86-64采用一系列约定去限制程序。

%rbx，%rbp和%r12-%r15被归类为callee saved的寄存器，当P调用Q的时候，Q必须保存寄存器的值。程序Q可以不改变寄存器的值，或者将原值推到栈上，修改以后在返回前从栈中弹出旧值来获得寄存器的值。寄存器的保存值和创建栈里saved registers一样的效果。所有其他除了%rsp的寄存器被分类为caller saved的寄存器，即可以被任何函数修改，名为caller saved可以被理解为P在这些寄存器又数据然后调用Q，由于Q可以修改寄存器因此P必须首先保存这些值。

考虑图3.34a的函数P，调用了Q两次，在第一次调用里必须保存x的值，在第二次调用的时候，必须保存Q(y)，在图3.34b里，可以看到gcc生成的代码使用两个寄存器保存值，%rbp保存x，%rbx保存Q(y)，在函数开始的时候，保存两个寄存器的值在栈里， 在第一次调用Q（第5行）之前，它将参数x复制到%rbp。在第二次调用Q（第8行）之前，它将这次调用的结果复制到%rbx。在函数的最后（第13-14行），它通过从栈中弹出两个保存的寄存器的值。

## 3.7.6 递归程序

每个程序调用都在栈上有自己的空间，因此多次调用的局部变量不会互相影响。栈提供了适当方法，在程序被调用时分配局部的存储，并在返回前将其删除。

图3.35显示针对递归阶乘函数的C和生成的汇编代码，可以看到汇编代码使用寄存器%rbx保存参数n，首先保存栈上的值后，在return前需要对值进行复原。由于栈的规则和寄存器保存的约定，可以发现当递归调用rfact(n-1)的时候，调用结果将被放在寄存器%rax上，参数n的值被保存在寄存器%rbx上，将这两个值相乘就可以计算出所需的结果。

可以从这个例子中看到，递归调用一个函数的过程就像其他函数调用一样。我们的堆栈纪律提供了一种机制，在这种机制中，每个函数的调用都有自己状态信息的私有存储（返回位置的保存值和调用保存的寄存器）。如果需要的话，它还可以为局部变量提供存储。

# 3.8 数组分配和访问

C的数组实现十分直接，因此转为机器码很直观，C特殊的特征在于我们可以生成指向数组元素的指针并用这些指针进行计算，这些被翻译为地址计算。

## 3.8.1 基础原则

考虑T A[N]；标记着开始位置为$x_A$的数组。这样的声明有两个作用，其一是在内存分配了连续的L*N字节，L就是这个数据类型T的长度，第二就是引入了A作为指针表示数组的开始，这个指针的值就是$x_A$，任何元素都可以通过0到N-1被访问，某个元素i地址就是$x_A+L * i$。

指令mov (%rdx,%rcx,4),%eax将会进行$x_E+4 * i$的地址计算，并读取值到%eax里。

## 3.8.2 指针运算

表达式Expr和*&Expr是等价的，因为&Expr是对象的地址，而 * 是取它的值。A[i]等价于*(A+i)，它计算了数组的第i个地址并访问内容。表格给出了表达式，类型以及值和汇编代码的内容。比较简单，可以跳过。

## 3.8.3 嵌套数组

int A[5] [3];等价于typedef int row3_t[3];和row3_t A[5]; 

在这里row3_t等价于三个数字的数组，数组A包含了五个这样的元素，每个需要12字节取存储三个整数，共60字节。为了访问多维数组的元素，编译器生成代码来计算所需元素的偏移量，然后使用mov指令中的一条，以数组的起始点为基址，以（可能是按比例）偏移量为索引。一般来说T D[R] [C];里某个元素D[i] [j]的地址如公式3.1所示。

给出了A[i] [j]复制到%eax的三个步骤，可以看到第一个指令是leap到%rax，将其值设置为3i，第二个指令是leap到%rax，将其设置为$x_A+12 * i$，第三步才是从其地址取元素复制到%eax里。

## 3.8.4 固定大小的数组

C编译器可以针对固定大小数组做出很多优化，我们给出了gcc在-01下的优化情况，假设我们声明fix_matrix为16*16的int数组。当一个程序使用常数作为数组维度时候推荐使用#typedef来声明。图3.37a的代码计算了数组A和数组B的点乘，gcc生成的代码以C的形式见图3.37b所示。代码包含了很多优化，这里还给出了汇编代码。

## 3.8.5 可变长度的数组

C只支持固定大小的多维数组，需要在编译时确定。程序员需要可变的数组的时候需要使用malloc和calloc。在C里声明大小可变数组必须声明int A[expr1] [expr2]，数组的长度当编译遇到expr1和expr2的时候决定。

这里给出了var_ele函数取返回n*n数组的某个元素，并给出了汇编代码。编译器必须先知道n才能计算A[n] [n]。代码计算第i行第j个元素是通过$x_A+4(n * i)+4j$来获得的。因此引用可变大小的数组必须使用一个乘法指令来扩展i的n，在一些处理器中，这种乘法可能会产生很大的性能损失，但在这种情况下是不可避免的。

当可变大小的数组在一个循环中被引用时，编译器通常可以通过利用访问模式的规律性来优化索引计算。图3.38a给出了C代码去计算，gcc生成了汇编代码，图b给出了汇编代码的C形式，图3.38b保存了循环变量j，一方面判断循环另一方面去索引A元素。

在启用优化的情况下，gcc能够识别程序在索引多维数组的元素时出现的问题。然后它可以生成代码，避免直接应用公式3.1而产生的乘法。不管是生成图3.37(b)的基于指针的代码还是图3.38(b)的基于数组的代码，这些优化都会显著提高程序的性能。

# 3.9 外部数据结构

C提供两种机制去创建数据多个类型结合的数据类型，即struct和union，前者把多个对象放到了一个单元里，后者允许使用几种不同的类型来引用一个对象。

## 3.9.1 Structures

C里的struct关键字用于创建将多个类型放到一个对象，不同组成由不同名字标记，其实现和数组类似，所有组成部分都存储在内存的一个连续区域中，一个结构的指针是其第一个字节的地址。编译器维护每个struct的信息，指出每个字段的字节偏移。它使用这些偏移量作为内存引用指令的位移，完成对其元素的引用。

假设变量r是结构体指针，并存在%rdi里，给出了将r.i复制到r.j的操作。如果想要生成&(r.a[1])则可以通过将偏移8+4*1获得。如果指针r在%rdi里且整数i在%rsi里，可以通过leaq 8(%rdi,%rsi,4),%rax去生成指针值&(r.a[i])。

一个struct的不同字段的选择完全是在编译时处理的。机器代码不包含关于其声明或字段名称的信息。

## 3.9.2 union

union提供了一种方法回避了C的类型，允许某个对象被多个类型引用。union声明的语法和struct一样但是含义却不相同。给出了S3和U3作为例子，当在x86-64机器上编译的时候，U3里三个类型偏移一样，且大小一样是8字节，这个大小是跟着其域内的最大字段。union往往会因为自己bypass了类型产生若干问题。

假设我们想要实现二叉树数据结构，每个节点有两个double数据，且有两个孩子。如果使用struct则需要32字节，然而这有一半的空间被浪费给了节点类型（左右孩子），而如果使用union，则每个节点只需要16字节。如果指针n指向了这个union，可以使用n->data[0]获得数据，而内部的孩子节点可以通过n->internal.left和n->internal.right获得。

上述声明没办法确定某个节点是叶节点还是内部节点，常用方法是引入枚举类型，然后创建一个structure去包含tag和这个union，这样的结构需要24字节，其中type是4字节，info.internal.left和right各8字节，也可以视为info.data需要16字节。在type和元素之间需要4字节填充，因此一共需要24字节。

unions也可以被用于访问不同数据类型的比特，比如我们有一个转换将d从double类型到unsigned long类型的u，u将会是d的整数表示，除了d是0.0，u的bit表示和d有很大不同。但是在double2bits代码里从double到unsigned long进行转换，参数使用double进行赋值但是使用另一个类型去访问，这样的结果就是u和d有相同的bit表示。

当使用unions去结合不同大小的数据类型时，字节顺序也就很重要，下面给的例子里，在x86-64这样的小端机器上word0是低位4字节，word1是高位，而大端相反。

## 3.9.3 数据对齐

许多计算机系统对原始数据类型的允许地址进行了限制，要求某些对象的地址必须是某个值K的倍数（K=2,4,8）。这样的策略简化了硬件设计并在处理器和存储系统之间简化了接口。如果一个处理器总是从内存取8字节，那么这个内存地址就得是8的倍数。如果我们可以保证某个double在8字节倍数对齐，那么就可以使用一个内存操作获得double数据，否则就是两次，这个对象就会分成两个8字节内存块。

X86-64硬件无论数据是否对齐都可以正确工作，Intel推荐数据对齐，对齐规则是任何K字节的对象都必须有一个K为倍数的起始地址。编译器在汇编代码放置指令标记数据的对齐方式，例如271页第二行的directive：.align 8。这就保证了后面的数据将以8的倍数的地址开始。 为了让代码遵守这样的结构，编译器可能需要嵌入空白以确保每个元素遵守这样的规则。考虑S1作为例子，S1本来是9个字节的，无法满足4字节的对齐规则，引入编译器嵌入3字节到char类型后就可以满足了。假设指针p标记S1的指针，则$x_p$必须代表4的倍数，p->i和p->j将满足4字节对齐规则。

此外编译器可能要在struct末端添加字节以满足对齐需求，考虑S2结构体，如果将结构体以9字节对齐，那么仍然可以满足对齐规则。考虑struct S2 d[4];这样的声明，单个d元素有9字节分配，那么加在一起就是$x_d,x_d+9,x_d+18,x_d+27$。实际上编译器会为S2分配12字节，每个元素有3字节的浪费，这样就是$x_d,x_d+12,x_d+24,x_d+36$，只要$x_d$是4的倍数，那么所有的对齐规则都会被满足。

# 3.10 在机器级程序结合控制和数据

目前我们已经了解了机器级代码如何实现程序的控制和数据结构。本部分里我们将看到数据和控制的作用的方式，首先了解指针，然后介绍GDB的用法，GDB用于测试机器级程序的详细操作，然后学习缓冲区溢出，最后学习机器级程序如何实现一个函数所需的栈大小在不同的执行过程中会有所不同的情况。

## 3.10.1 理解指针

指针以统一方式对不同数据结构生成引用，在这里强调一些指针的关键点和他们映射到机器码的关键原则。

- 每个指针都有自己的相关类型，指针类型标记了指针指向了哪种的对象，比如下面的两个例子，变量ip是指向int的指针，cpp是一个指向对象的指针，这个对象自身是一个指向char对象的指针。一般来说如果对象类型是T，那么指针类型就是*T，特殊的void *类型代表generic指针，比如malloc函数就返回一个generic指针，然后要么通过直接类型转换要么通过隐式赋值的类型转换进行转换。指针类型并不显示在机器码里，他们只是C给程序员提供的抽象。
- 每个指针都有一个值，值是某个类型对象的地址，NULL代表空指针。
- 指针可以通过&创建，以&开头的C语句往往通过leaq指令计算。因为leap指令往往是被设计计算内存引用的地址。
- 指针通过*完成去引用，结果是一个值且和指针类型相同，去引用通过内存引用实现，要么是从某个地址存储值或者取回值。
- 数组和指针紧密关联，数组名字就是指针变量，a[3]和*(a+3)一个意思，数组引用和指针运算需要用对象大小对offset进行设置，比如针对表达式p写出来p+i，其实地址是p+L * i，其中L是p关联的数据类型大小。
- 从一个指针类型到另一个类型转换的时候不改变值，如果p是一个char *类型且值为p，那么表达式(int *)p+7计算的是p+28，而(int *)(p+7)计算的是p+7。（强制转换优先级高于加法）
- 指针也可以指向函数，例如有一个函数int fun(int x,int *p)，通过如下例子定义 fp为指向该函数的指针，注意fp定义的时候是int ( * fp)(int, int *)和fp=fun。函数指针是对应函数第一个指令地址。

## 3.10.2 使用GDB debugger

GNU调试器GDB提供了很多有用的特征去实时评估和分析机器级程序，有了GDB可以研究一个程序的行为，可以在程序执行的时候进行控制。

图3.39给出了一些GDB命令，用于研究x86-64程序，首先运行OBJDUMP获得程序反汇编版本是很有用的，我们的例子是GDB prog，程序见图211，可以使用gdb prog进行开始。

通常来说给自己想要研究的地方设置断点，断点可以设置在函数入口或者程序地址的后面，当某个断点命中的时候，程序会暂停并将控制器给用户。从断点可以看到不同的寄存器和内存地址，可以进行步过程序，一次执行一些指令或者直接跳到下个断点。

一些程序员更喜欢使用DDD，一个GDB拓展提供了诸多图形化接口。

## 3.10.3 外界内存引用和缓冲区溢出

C对于数组引用不做越界检查，而且局部变量被存储在栈里，而栈里还有返回地址和各种寄存器值，这些累加就会导致严重的程序错误，因为存储在栈的状态信息可以受到污染，而当程序尝试重新加载寄存器或者执行ret指令的时候，就会发生错误。

一个例子就是缓冲区溢出，一般来说，一些字符数字被分配在栈上去保存一个字符串，但是字符串大小可能会超过数组分配的空间。如接下来的例子。代码给出了库函数gets的实现以表示这个函数存在的问题，它从标准输入读取一行，当遇到一个新行字符或者一些错误时停止，它复制字符串到参数s的位置并以null字符结束，我们给出了echo函数里gets的用法，它从标准输入读取一行并输出到标准输出。

gets的问题是没有办法决定是否有充足的空间被分配给整个字符串，在echo例子里我们故意使得缓存非常小即8个字符，任何长于7个字符的字符串都会造成越界写。接下来给出gcc对echo的汇编代码。图3.40给出了echo执行时栈的组织，首先分配24字节的栈空间，字符buf放在了栈顶，然后复制%rsp到%rdi作为参数去调用gets和puts，buf和puts有16字节没有使用，只要用户最多7个字符，那么gets返回到字符串就会填充好buf的空间，一个更长的字符串会造成gets写入过多的信息到栈里，因此后面的信息都会被污染。

字符串到23个字符前都没什么严重后果，但是超过以后返回地址和可能保存的额外状态都会被污染，如果返回地址被污染则ret会让程序跳转到未知位置。

我们的echo过于简单了，一个更好的版本是使用fgets，他可以以一个参数作为最大读取的字节数。3.71的问题要求你写出一个echo函数，它可以处理任意长度输入。一般来说，gets或者任何可能造成缓冲区溢出的函数都会被认为是不好的实践，但是实际上很多知名的库如strcpy，strcat以及sprintf都有这样的问题。

缓冲区溢出的更严重问题在于让程序运行某个不愿意执行的函数，一般来说程序被给予一个字符串，其中包含了一些exploit code和额外的代码去覆盖了程序的返回地址以让返回地址指向exploit code。

在一种攻击形式里，exploit code会执行系统调用开启一个shell程序，提供攻击者一系列的可运行OS函数，另一种形式里，利用代码会运行一些未授权任务，然后修复栈，再二次ret给用户，让用户无法察觉。

著名的88年10月使用了四种不同方式获得因特网里电脑的权限，第一种是在fingerd的缓冲区溢出攻击，通过用一个字符串调用FINGER，蠕虫病毒使远程的守护进程出现缓冲区溢出并执行给蠕虫进入系统的代码。一旦蠕虫获得控制权，就可以自我复制并消耗资源，最后很多机器受到牵连。

## 3.10.4 对抗缓冲区溢出攻击

本节介绍一些由GCC提供的对抗缓冲区溢出攻击的机制。

### 1 栈随机化

为了给系统注入exploit code，攻击者需要注入代码和指向这段代码的指针，以作为攻击字符串。生成这个指针需要知道字符串在栈地址的哪个部分，在过去栈的地址很容易预测，那么如果攻击者可以知道某个常用WEB服务器的栈地址，就可以设计攻击很多机器。

栈随机化的思想是让栈的位置在程序每次运行时都会有变化，这样即使很多机器运行着一样的代码也会有不同的栈空间。这样的方法被实现通过在栈上分配一个0-n字节的空间，这样的空间不被程序应用，但是它会造成后面的栈位置都随着程序的执行发生变化。注意分配的范围n需要足够大以让栈空间获得充足变化。下面给出的代码展示了这样的例子，即不论在32位还是64位机器上，local的地址都是不同的。

栈随机化已经变成了linux系统的常见实践，本质上它是地址空间随机化技术的一种，简称为ASLR，使用ASLR程序的不同部分即程序代码，库代码，栈，全局变量和堆数据都在内存的不同位置。不同机器随机情况不同，因此可以抵御攻击。

然而攻击者可以通过暴力破解抵抗随机化，不断尝试不同地址的攻击，一个常见的技术是在exploit code前面加一长串的nop指令，这些nop指令没啥影响，只要攻击者可以猜中在这段序列的地址，那么程序就会最终命中exploit code。如果建立256个字节的nop sled，那么枚举$2^{15}$个其实地址就可以破解$n=2^{23}$的随机化。

### 2 栈破坏检测

第二道防线是可以检测栈什么时候被污染，可以看到图3.40的例子，破坏往往发生在程序越缓存边界，在C里没有方法检测越界，但是实际上程序可以检测这样的写入发生。

GCC加入了stack protector机制去检测溢出，思想是在栈状态和局部缓存中间加入canary值，如图3.42所示。canary值作为守护值，每次程序运行的时候随机生成，攻击者很难知道它的值，在复原寄存器的值和函数返回前，程序检查canary是否被当前函数或者调用当前函数的函数修改了，如果是程序会报错退出。

最近的GCC版本会确定某个函数是否容易遭受缓冲区溢出并自动嵌入这样的值，而在早起的缓冲区溢出例子里，我们实际上是通过-fno-stack-protector以防止GCC嵌入这样的值，受到保护的echo由gcc编译出来的代码如下所示。

我们可以看到这个版本从内存取出一个值并以%rsp后面第8个偏移位置进行存储，正好是在buf的后面，指令里的参数%fs:40显示了canary值被从内存里使用段地址读取，段机制寻址可以追溯到80286，现在很少见到了。在这个段里存储canary后即标记为只读，这样攻击者就无法覆盖canary值，在恢复寄存器状态和返回函数之前，函数会将存储在栈位置的值通过xor指令进行比较，判断是否为0，如果是0则正常退出，否则就是显示被覆盖，立刻error。

这样的方法很好的预防了缓冲区溢出，而且代价很小，而且GCC只会在函数里有char类型的局部buffer时才会防止canary值。

### 3 限制可执行代码区域

最后一招是消除攻击者插入可执行代码到系统的能力，一个方法是限制哪个内存区域可以放置可执行代码，只有存放编译器生成的代码的那部分内存需要是可执行的。其他部分可以被限制，只允许读和写。正如我们在第九章看到的，虚拟地址空间逻辑上分为pages，通常一page是2048或4096字节，硬件支持不同形式的内存保护，显示了用户程序和OS内核访问的形式。很多系统允许三种形式的控制即读写执行，历史上，X86架构将读和执行的访问控制合并为一个单一的1 bit标志，因此任何被标记为可读的页面也是可执行的。栈必须同时保持可读和可写，因此栈上的字节也是可执行的。为了能够限制一些页面的可读性而不是可执行性，我们实施了各种方案，但这些方案通常会带来显著的低效率。

近来AMD针对64位处理器引入NX bit到内存保护里，分散读和执行访问模式，INTEL随后也做到了。在这种模式下，栈被标记为可读和可写但是不可执行，而检查页是否可执行由硬件完成，效率损失为0。

注意三种方法并不是万能，仍然有论文85和97可以对计算机进行攻击。

## 3.10.5 支持可变大小的栈

目前看到的程序编译器都必须提前决定栈的空间，一些函数实际上需要大量的可变局部变量，这可以使用alloca来实现，它可以分配栈上任意字节。

图3.43a给出了一个包含可变数组的例子，函数声明了本地数组p，里面有n个指针，n的值由第一个参数给出，这需要在栈上分配8n字节，n的值可能会变化。编译器因此无法决定要在栈上分配多少空间。此外程序生成了对局部变量i的引用，因此这个变量也要存在栈上，执行期间程序必须可以访问i和p的元素，返回的时候程序必须将栈空间收回。

为了管理大小可变的栈，x86-64代码使用%rbp作为frame指针，在使用以后，栈就如图3.44的形式一样，可以看到代码必须保存以前的%rbp在栈上，然后让%rbp作为基地址去引用固定大小的局部变量。图3.43b展示了GCC为vframe函数生成的代码部分，在函数开始，可以看到代码设置好栈并为数组p分配空间，代码首先将%rbp当前值加入栈里然后设置%rbp为栈的部分。然后分配栈的16字节，前8个被用于存储i，后面8个字节不使用。然后为数组p分配空间，当程序到第11行的时候，已经完成了8n字节的分配并在分配好的区域放置好了数组p，包含了8n字节。

初始化循环的代码展示了本地变量i和p如何被引用的例子，第13行给出了p[i]被设置为q，这个指令使用%rcx的值作为p开始的地址，可以看到局部变量i在15行被更新，在17行被读取，i的地址是引用-8(%rbp)获得的。在函数结尾，栈桢指针被通过leave指令恢复为以前的值，它无参数，等价于两条指针，第一条将%rsp设置为目前%rbp的位置，然后恢复以前%rbp的值。

使用栈桢指针的代码和不使用代码是可以的，前提是所有的函数都将%rbp当作调用者保存的寄存器。

# 3.11 浮点代码

处理器的浮点运算体系包括了多个方面，这回影响程序对浮点数数据的操作如何映射到机器上。这包括了：

1. 浮点数如何被存储和访问，这通常通过寄存器完成。
2. 操作浮点数的指令。
3. 传递浮点数作为参数和从函数返回浮点数的规则。
4. 函数调用期间寄存器如何保存的规则，例如一些寄存器用于caller的保存，而其他寄存器用于callee保存。

从历史可以对x86-64浮点架构的理解有帮助，由于1997年MMX的引入，intel和AMD都引入media指令去支持图形处理，这些指令本来是想允许多个操作以并行方式运行，这称为单指令多数据（SIMD）。在这种模式下可以对大量不同数据并行执行某个操作。最近这些操作又了长足发展，名字从MMX到SSE再到AVX，每个这样的拓展都管理寄存器组中的数据，例如AVX管理256位的YMM寄存器，每个YMM寄存器可以放8个32 bit值或4个64 bit的值，这些值要么是整数要么是浮点数。

2000年Pentium4引入SSE2，开始包括对浮点数进行操作的指令，它使用了XMM或者YMM的低32 64比特位。这个模式提供了大量寄存器和指令，更类似于其他处理器处理浮点数的方式，所有能执行x86-64代码的处理器都支持SSE2和更高版本，因此x86-64是基于SSE或AVX的。

本节是基于AVX2的，即AVX的第二个版本，在2013年的i7处理器引入，GCC在参数-mavx2下生成AVX2代码，基于不同版本的SSE和第一个版本的AVX代码概念上类似但是指令名和格式不同，我们只介绍使用GCC编译浮点程序出现的指令。大部分是AVX指令，和整数操作一样，我们给出的指令是ATT格式，有区别于INTEL格式，这两个版本的指令操作数顺序不同。

如图3.45所示，AVX浮点架构允许数据存储在16个YMM寄存器里，名字是%ymm0-%ymm15，每个YMM寄存器都是32字节长度，当对scalar数据操作的时候，这些寄存器只保留浮点数数据，只有低32和64bit被使用。汇编代码通过SSE XMM寄存器来引用这些寄存器，名为%xmm0-%xmm15。每个XMM寄存器都是YMM寄存器的低16字节。

## 3.11.1 浮点数移动和转换指令

图3-46给出了将浮点数数据在内存和XMM寄存器之间转换，以及XMM寄存器之间转换的指令，引用内存的指令被称为scalar指令，这意味着他们的操作数是一个值，数据要么保存在内存里要么保存在XMM寄存器里。无论数据对齐与否这些指令都会正确工作（虽然代码优化推荐32位机器需要满足4比特对齐，64机器需要满足8比特对齐），内存引用的方式和MOV一样。

GCC只对从内存转移到XMM寄存器或者从XMM寄存器转移到内存时才使用scalar移动操作。在两个XMM寄存器之间转移数据，只需要使用vmovaps和vmovapd，前者用于单精度数据的转移，后者用于double精度的数据转移，程序是复制整个寄存器还是只复制低阶值，既不影响程序的功能，也不影响执行速度，所以使用这些指令而不是专门针对scalar数据的指令，并没有实际的区别。这些指令名称中的字母'a'代表了 "对齐"。当用于读写内存时，如果地址不满足16字节的对齐方式，它们会引起异常。对于两个寄存器之间的传输，不可能出现不正确的对齐。

给出C函数float_mov，它是不同浮点数移动操作的例子，给出了x86-64汇编代码。可以看到vmovaps指令是从一个寄存器复制值到另一个寄存器，而vmovss指令是从内存复制数据到一个XMM寄存器和从XMM寄存器复制到内存。

图3.47和图3.48给出了在浮点数和整数之间，以及不同浮点格式转换的指令，这些都是对单个数据值进行操作的scalar指令。在图3.47的指令从XMM寄存器或者内存里读取一个浮点数值，将其转换并写入一个普通寄存器如%rax和%rbx，当从浮点数转为整数的时候会进行截断。图3.48的指令将整数转为浮点数，使用三操作数格式，其中包含了两个源操作数和一个目的操作数，第一个操作数从内存或者一个寄存器里获得，我们可以忽略第二个操作数因为它的值只会影响结果的前半部字节，目的地址必须是一个XMM寄存器，在一般用法里第二个操作数和目的操作数必须是一致的，就像vcvtsi2sdq %rax,%xmm1,%xmm1这条指令从寄存器%rax获得一个长整数，然后将其转换为double，并存储他的值在XMM寄存器%xmm1的低位里。最后对于在两个不同浮点格式里转换，当前GCC版本生成的代码需要单独说明，假设%xmm9的低4个字节保留了单精度值，很容易就可以想到vcvtss2sd %xmm0,%xmm0,%xmm0去把单精度转为双精度值并存储在%xmm0的低8字节里。我们发现了GCC生成的代码如下。

其中vunpcklps指令被用于交叉放置来自两个XMM寄存器的值，并存储它在第三个寄存器，也就是说如果一个源寄存器包含了$[s_3,s_2,s_1,s_0]$且另一个包含了$[d_3,d_2,d_1,d_0]$，那么目的寄存器的值就是$[s_1,d_1,s_0,d_0]$。在上面代码里可以看到三个操作数都是一个寄存器，如果原始寄存器的值是$[x_3,x_2,x_1,x_0]$，那么这条指令会更新寄存器为$[x_1,x_1,x_0,x_0]$。vcvtps2pd指令扩大单精度值为双精度值，最后xunpcklps指令将给值$[dx_0,dx_0]$，而$dx_0$是将x转为双精度的结果，故这两个指令的影响就是将%xmm0低4字节的单精度数转换成了双精度数，并存储了2个副本在%xmm0。

对于双精度转换为单精度，GCC会生成类似代码，假设指令以%xmm0开始，有两个双精度值$[x_1,x_0]$，vmovddup指令将设置它为$[x_0,x_0]$，vcvtpd2psx指令将转换这些值为单精度，并打包他们倒寄存器低位，设置高位为0，产生结果$[0.0,0.0,x_0,x_0]$。

总结一下，GCC在精度转换的时候都是使用两个指令完成，而不是单精度去完成。

## 3.11.2 函数中的浮点数

在x86-64里，XMM寄存器被用于传递浮点参数给函数并返回浮点数值，如图3.45所示，可以看到如下规则。

1. XMM寄存器最多可以传递8个参数，这8个寄存器是%xmm0-%xmm7，这些寄存器按照参数列出的顺序使用这些寄存器，额外的参数将会放到栈里。
2. 函数使用寄存器%xmm0返回浮点值。
3. 所有的XMM寄存器都是调用者程序保存的，因此被调用者可以不用保存就修改这些寄存器。

当一个函数包含指针，整数，浮点数参数时，指针和整数可以用普通寄存器传递，而浮点数必须通过XMM寄存器传递，即参数到寄存器的映射取决于他的类型和排列顺序。

## 3.11.3 浮点运算操作

图3.49给出了一系列scalar AVX2浮点数指令，每个指令有1到两个操作数和目的操作数D。第一个操作数是$S_1$，要么是在XMM寄存器要么是在内存里。第二个源操作数和目的地址必须是XMM寄存器。每个操作都有对单精度和双精度的指令，结果存储在目的寄存器里。

下面的例子里，首先对x的类型转为double，然后乘以a，再对i进行double类型转换，计算得到b/i，最后将差值存储在%xmm0里。

## 3.11.4  定义和使用浮点数常数

和证书不同，AVX浮点数操作无法以立即数作为操作数，编译器必须分配并初始化常数的空间，代码然后从内存读取这个值，下面的例子是从摄氏度到华氏度的转换。

可以看到函数读取常数1.8是从标记为.LC2的地方获得的。可以看到这些值，每个都用一对.long和十进制表示的值指定的，由于机器是小端存储，因此第一个值给的是低4个字节，第二个值是高4个字节。从高位字节和低位字节可以获得对浮点数的编码。

## 3.11.5 在浮点代码里使用位操作

图3.50展示了对寄存器进行位操作的指令，注意这些指令会对整个XMM寄存器的128比特产生影响，而我们只对低字节感兴趣。

## 3.11.6 浮点数比较操作

AVX2给出了两个指令比较浮点数，这两条指令类似于CMP，比较$S_1$和$S_2$，设置条件码显示两者的大小，和cmpq指令一样，这两条指令遵守ATT格式，即以反顺序列举操作数。参数$S_2$必须是XMM寄存器，而$S_1$可以是XMM寄存器，也可以是内存。

浮点数指令主要修改三个条件码即ZF，CF和PF。对于整数操作，如果最近一次运算产生的值字节有偶数个1则设置这个标志位，而对于浮点数来说，如果两个源操作数有一个是NAN则会设置PF。条件码的设置可以见下表。

当任一操作数是NAN的时候，就会出现Unordered的情况，可以通过PF设置这样的结果。可以根据ja，jb等指令设置跳转的情况。

来看浮点比较的例子，图3.51a给出了根据x和0.0比较的情况返回一个枚举类型作为结果。当x的值是NAN时就会出现最后一个结果，即RESULT=OTHER。

GCC生成的汇编代码如图3.51 b给出，这段代码并不高效，因为比较了x和0.0三次，还生成了0.0两次，一次使用vxorps，一次从内存里读取值。下面给出了4种情况的跳转。

## 3.11.7 浮点代码的结论

AVX2浮点数据进行操作所产生的机器代码的风格与我们看到的对整数数据进行操作的机器代码相似。两者都使用寄存器的集合来保存和操作数值，并使用这些寄存器来传递函数参数。

AVX2对打包的数据进行并行操作提供可能，使计算运行得更快。编译器开发人员正在努力自动将scalar代码转换为并行代码，但目前通过并行实现更高性能的最可靠的方法是使用gcc支持的C语言的扩展来处理数据的vectors。