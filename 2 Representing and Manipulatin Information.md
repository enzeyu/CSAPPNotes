# 前言

在构建存储和处理信息的机器时，二进制值效果更好。双值信号可以很容易地表示、存储和传输。

本章介绍几种不同的二进制表示去编码数值的方法。我们从编码的基本定义开始，然后推导出可表示数字的范围、其位级表示形式以及算术运算的属性等属性。

# 2.1 信息存储

大多数计算机使用8比特的块也称为字节去访问内存，比特也是内存的最小单元。计算机级程序将内存视为非常大的字节数组，称为虚拟内存。内存的每个字节都由一个唯一的数字（称为其地址）标识，虚拟地址空间的实现使用动态随机存取存储器（DRAM），闪存，磁盘存储，特殊硬件和操作系统软件的组合。

## 2.1.1 十六进制符号

由于二进制过于冗长，十进制和其他进制的转换是复杂的，因此有了十六进制。C语言里以0x开头被认为是十六进制。

这部分主要介绍了十六进制和十进制的相互转换。

## 2.1.2 数据大小

每个计算机都有word大小，这也是指针数据的大小。针对一个w比特的word大小，虚拟地址可以从0映射到$2^{31}-1$，程序最多可以访问$2^w$字节。

近年有从32bit word大小到64bit word大小设备的转换，32比特word大小限制了虚拟地址空间只能是4GB，约$4*10^9$字节，64比特word大小导致了虚拟地址空间是$16EB=16*2^{60}$字节。

编译32bit和64bit的程序是有区别的，64位程序往往可以运行在32位上，反之不行。为了防止32比特机器和64比特机器带来的类型不同，ISO C99引入了一组固定大小的数据类型。

## 2.1.3 字节排序

针对程序对象，必须建立两个约定：

1. 对象的地址是什么
2. 以什么样的顺序排列内存里的字节

在计算机里，多比特对象是一段连续的字节序列，地址就是这段序列的最低地址。一个4字节的整形变量x地址是0x100，那么他实际占用的空间是0x100，0x101，0x102，0x103。

如何排列字节有两种方式，一些机器从最低位到最高位存储，一些机器从最高位到最低位进行存储。前者称为little endian，后者是big endian。大多数英特尔架构机器使用little endian，大多数IBM和ORACLE是big endian。

为了防止字节方式排列的不同引发的问题（从小顶端机器到大顶端机器），针对网络应用的代码必须遵守字节排序的规定以确保发送的机器转换内部表示为网络标准，接受的机器再将网络标准转为内部状态。

图2.4给出了使用强制类型转换来访问和打印不同程序对象字节的表示。使用typedef unsigned char *byte_pointer去让 byte_pointer定义为一个指向类型为“unsigned char”的对象的指针，里面存储的是这个对象的地址。图2.6给出了结果，一个值得注意的特性是Linux 32、Windows和Sun的机器使用4字节地址，而Linux 64使用8字节地址。注意12345和12345.0虽然是一样的数值，但是十六进制表示完全不同，将其展开后发现一共有13bit一致，这并不是巧合。

## 2.1.5 布尔运算

注意，布尔运算可以一定程度上代表了集合的交和并，例如a=[01101001]

，b=[01010101]，前者代表一个集合，里面的元素为{0,3,5,6}，后者代表集合，里面的元素为{0,2,4,6}，a&b=[01000001]，代表a和b的交集为{0,6}。a|b代表了并集。

常见的布尔运算包括  ~ & | ^，即取反，且，或，异或。

## 2.1.8 C的逻辑运算

提供了||，&&，!，分别对应或，且和否。逻辑运算很容易和位级运算相混淆，但是它们完全不同。逻辑运算认为所有非零的参数都表示TRUE，而参数0表示FALSE。另一个不同是逻辑运算符不看第二个参数，当表达式的结果可以被第一个参数决定时。

## 2.1.9 C的移位运算

左移运算没什么好说的，值得一提的是右移运算，支持两种形式，以x>>k为例子。

1. 逻辑右移：逻辑右移使用k个0填充左边的k位。
2. 算数右移：算数右移使用k个最重要的重复bit位(首位)进行填充，这虽然有点奇怪，但是对操作有符号整数很有用。

实际里，几乎所有编译器/机器组合都对有符号数据使用算术右移位。对无符号数，使用的是逻辑右移。和C不一样的是，JAVA提供了右移到精确定义，x>>k代表算数右移，而x>>>k代表逻辑右移。

注意在C里移位运算符的优先级比加号优先级低，因此1<<2 + 3<<4并不代表(1<<2) + (3<<4)

# 2.2 整数表示

这一部介绍两种编码整数的方式，一种只代表非负数，一种代表负数，0和正数。

## 2.2.1 整形数据类型

唯一和机器相关的数据类型是long，大多数64位机器使用8字节表示，一些32位机器使用4字节表示。

## 2.2.2 无符号编码

考虑w bit的整形数据，无符号编码算出来的值如公式2.1所示。

无符号二进制表示的重要性质是，每个数字在0到$2^w-1$之间，且可以被唯一表示，反之也是一样，这样在数学上称为bijection(双射)。

## 2.2.3 二进制补码编码

有符号数的最常表示方法是二进制补码，它通过将最高位变负给出，假设一共w bit的向量$x=[x_{w-1},...x_0]$，运算公式为$-x_{w-1}*2^{w-1}+\sum_{i=0}^{w-2}x_i2^i$，故其表示范围为$-2^{w-1}$到$2^w-1$。

TMin是最小值，TMax是最大值，如图2.9和2.10所示，|TMin|=|TMax|+1，这是不对称的，这是因为一半bit表示(最高bit为1)代表了负数，另一半(最高bit为0)代表非负数，由于0是非负数，故正数的表示比负数少一个。第二，最大的无符号数UMAX=2TMAX+1。图2.14给出了常数的表示，-1和最大的无符号数表示是一样。

图2.15给出了12345和-12345的二进制补码表示和53191的无符号表示，这里53191和-12345的向量是一样的。

## 2.2.4 有符号和无符号的转换

将负数转为无符号可能会产生0，将位数短的负整形转为无符号数的时候，可能会出现错误，比如图2.15里的-12345到53191的转换，这样转换改变了数值但是实际上没有改变位的表示方式。

注意到$12345+53191=65536=2^{16}$，故可以得出规律w比特的表示里$1+UMAX_w=2^w$，这里的$UMAX_w$代表w位表示的最大无符号数。

公式2.5给出了二进制补码转为无符号数的规则，当x>=0时候，转的结果不变，否则$x+2^w$，例如$-12345+2^{16}=53191$。公式2.6给出了补码转二进制，二进制再转无符号的情况，结果等于当前的补码值$+x_{w-1}*2^w$。

公式2.7给出了无符号数专为二进制补码的情况，公式2.8给出了无符号数转为二进制的法则。

## 2.2.5 C语言里有符号对比无符号

虽然C标准没有限定有符号数的特定表示，但是几乎所有机器都适用补码。

C允许无符号和有符号之间的转变，大多数系统都遵守bit表示不变的规则。

## 2.2.6 扩大数的bit表示

从一个小的数据结构转为大的数据结构往往是可行的，补0的操作被称为0拓展，分为两个方式：

1. 无符号数的零拓展：在最前面补充0即可。
2. 二进制补码的零拓展：在最前面补充最高位。

这里给出一个推导，理解[1110]和[110]两个二进制向量表示的值相等，都为-2即可。

## 2.2.7 截短数字

想象一下，截短数字的比特表示，例如从32bit的int截短到16bit的short里，只需要舍弃前16位即可。

这里给出了截断无符号数和截断二进制数的区别，他们都有一个相似的性质，即$x'=x mod 2^k$。

## 2.2.8 关于有符号和无符号数的建议

练习2.25很实用，错误在于length是无符号数，当length=0时，如果运算length-1，将会遵守无符号数的运算，表示为0+(-1)=0+11111111=UMAX，导致错误。

解决办法就是要么i<=length，要么改length为整形。

练习2.26里，当s短于t就出错，即当strlen(s)=0而strlen(t)>0时，例如0+(-1)=0+11111111=UMAX，这就导致错误的结果。修正在于改为strlen(s)>strlen(t)，因为它没有通过运算进行比较。

有符号到无符号的隐式转换，可能导致错误或漏洞。避免此类错误的一种方法是永远不要使用无符号数字。事实上，除了C之外，很少有语言支持无符号整数。

# 2.3 整数运算

x<y和x-y<0可能会产生不一样的结果，这也是练习2.26想表达的。

## 2.3.1 无符号加法

考虑x和y都是w个bit位的无符号数，显然$0<=x,y<2^w$，故x+y的范围是$0<=x+y<=2^w-2$，这需要w+1个bit位表示了，考虑x+y=9+12=21，故[1001]+[1100]=[10101]，丢弃最高bit，就可以得到[0101]，得到了5，注意21 mod 16 = 5。

公式2.11给出了无符号数相加的溢出和正常情况。

**检测无符号加法的溢出**：当s=x+y时，s<x或者s<y时则发生了溢出。

**无符号的negation：**对$0<=x<2^w$的x，他们的w位无符号negation由公式2.12所示。

## 2.3.2 二进制补码加法

在做二进制补码加法里，必须决定结果过大或者过小时怎么处理，给定x和y的范围为$−2^{w−1} ≤ x, y ≤ 2^{w−1} − 1,$则他们的和范围为$−2^{w} ≤ x, y ≤ 2^{w} − 2$,可能需要w+1个bit位去表示。公式2.13给出了将x+y的结果缩减为w个bit位的结果，这里直接看图2.25所示的例子即可。

下列给出了检测二进制补码加法的例子：

如果x+y=s，在x>0,y>0而s<0时，说明发生了正溢出，当x<0,y<0而s>0时发生了负溢出。

## 2.3.3 二进制补码negation（存疑）

公式2.15给出了二进制补码的negation。

这里给的似乎就是负数。

## 2.3.4 无符号数的乘法

两个w bit的无符号数乘积可到达2w bit，C里的无符号乘积得到了w bit的值，它是2w的低位w bit，将一个无符号数缩减到w bit等价于计算它的值 $mod 2^w$。

## 2.3.5 二进制补码乘法

一个w bit的二进制补码范围为$[-2^{w-1},2^{w-1}-1]$，两个w bit的二进制补码乘积可达2w bit，有符号乘积需要将2w bit缩减为w bit，其步骤首先将二进制补码mod $2^w$，然后从无符号数转为二进制补码。

## 2.3.6 常数乘积

历史上整数乘积指令很慢，大约需要10个或者更多的时钟周期，然而其他的操作例如加减初，bit运算，移位都只需要1个时钟周期。编译器使用的一个重要优化是尝试用移位和加法运算的组合来替换常数因子的乘法。首先考虑以2为底的次方，再看其他的数字。

2次方乘法：x是无符号整数，二进制表示为$[x_{w-1}...x_0]$，对于任何k>=0，w+k bit的无符号表示为$x*2^k$，二进制表示为$[x_{w-1}...x_0,0...0]$，即k个0被增加到了右边。（本质上就是左移一位乘2倍）

无符号数的乘积没啥好说的吧，x<<k等价于$x*2^k$，二进制补码的乘积也是同理，但是无符号或者二进制补码运算可能会造成溢出，例如4 bit的[1011]左移2bit为[101100]，从11变成了44，但是经过缩减为4bit后，就是1100，即12，这里是44 mod 16=12。

因为乘积太费时间了，所以编译器想要通过使用移位，加法以及减法来代替，例如x*14，$14=2^3+2^2+2^1$，编译器会写成(x<<3)+(x<<2)+(x<<1)，也可以写成$14=2^4-2^1$，即(x<<4)-(x<<1)。

## 2.3.7 除以2的幂

整数除法比整数乘法还要慢，往往需要30个时钟周期，除以2的幂可以通过右移实现，无符号和二进制补码分别使用逻辑右移和算数右移。

**无符号除2的幂**：针对x和k都是无符号数的情况，x>>k等价于$x/2^k$的下界。图28给出了逻辑右移k位和除$2^k$有一样的影响，逻辑右移前面补0。

**二进制补码除2的幂**：针对x是二进制补码，k是无符号数的情况，x>>k等价于算数右移，会产生$x/2^k$的下界。

比较遗憾的是找不到一种组合方法去运算除以任意值，这和乘法不一样。

# 2.4 浮点数

如今，几乎所有计算机都支持IEEE浮点。这大大提高了科学应用程序在不同机器上的可移植性。

## 2.4.1 二进制的小数

理解浮点数的第一步是考虑有小数的二进制，例如$12.34=1*10^1+2^10^0+3*10^-1+4*10^-2$，而$101.11_2=1*2^2+0*2^1+1*2^0+1*2^{-1}+1*2^{-2}=23/4$。

十进制表示无法表示如1/3和5/7的数，其他的数只能近似。

## 2.4.2 IEEE浮点表示

**整型只能表示范围较小的数，但它能表示的每个数都是准确的。浮点数虽然能编码一个很大的范围，但这种表示只是近似的。**

IEEE浮点数标准以$V=(-1)^s*M*2^E$的形式表示数据，s表示数字的正负，M是小数二进制数，范围在1到$2-\epsilon$或者0到$1-\epsilon$之间，E代表2的幂次。浮点数的比特表示被分为三个部分去表示这些值：

1. 符号位s：符号比特s直接表示s
2. 阶码exp：k个bit编码了E，结果需要减去偏置值
3. 尾数frac：n个bit编码了M，但是这个值依赖于数字是规格化数还是非规格化数

图2.32给出了汇总这三个部分表示为两种传统的格式，在单精度浮点格式里，s=1，k=8，n=23，表示32bit。在双精度浮点格式里，s=1，k=11，n=52，表示64bit。根据E的不同，值可以分为三种情况。

**规格化值：**最常见的情况，当E的比特表示既不是全0也不是全1时产生。exp的编码区域无符号值为e，但是阶码的值为E=e-Bias，Bias是偏移量，值为$2^{k-1}-1$，k表示阶码的位数。单精度的Bias是127，e的范围是1-254，E的范围是-126到127，双精度的Bias是1023，e的范围是1-2046，E的范围是-1022到1023。表格2.34可以好好看看。

比如整形数据12345转换为float，首先使用二进制表示12345=11000000111001，将小数点向左移动13位，进行规格化，即$12345=1.1000000111001 * 2^{13}$，接下来进行浮点数编码，首先符号位是0，其次阶码的值E为13，E=e-Bias，e=E+Bias=E+127=140，所以阶码字段就是140的八位二进制表示，上述规格化形式的小数部分，后续添0添到23位，也就是添10个0，构造frac字段，即10000001110010000000000。最终32位的单精度浮点数编码为 0 10001100 10000001110010000000000。

**非正则化值：**当E的比特全是0的时候，数字是非正则化形式。对于阶码字段，阶码值E改成了E = 1 - Bias，而单精度非规格化的数的E是-126，双精度非规格化数的E是-1022。零的表示就是exp和frac字段全为0，因此，对于浮点数来说，还有正零和负零的区别。

**特殊值：**第一类是exp全为1而frac全为0时，表示的值是无穷，当s=1代表负无穷，s=0表示正无穷。

## 2.4.4 舍入

对于某个运算结果x，我们需要想出一个系统的方法，找到一个能够用浮点编码表示的“最接近”的匹配值x1，用x1来表示运算结果。这就是舍入的任务。

浮点数采取的规则是**舍入到偶数**，即：将数字向上或向下舍入，使得结果的最低有效数字是偶数。如果是按照舍入到偶数，那么2.5和1.5都是舍入成2的。可以认为舍入到偶数是一种比四舍五入更加“**公平**”的舍入方法，我们把中间值5，一半向上舍入，一半向下舍入，那么就在大多数的现实情况中避免了计算的统计偏差。

## 2.4.5 浮点运算

### 加法

$(-1)^{s_1}*M_1*2^{E_1}+(-1)^{s_2}*M_2*2^{E_2}=(-1)^s*M*2^E$，其中$s=s1 \^  s2$，$M=M_1+M_2$，$E=E_1$

### 乘法

$(-1)^{s_1}*M_1*2^{E_1}*(-1)^{s_2}*M_2*2^{E_2}=(-1)^s*M*2^E$，其中$s=s1 \^  s2$，$M=M_1*M_2$，$E=E_1+E_2$

浮点数运算满足交换律不满足结合律。例如表达式（3.14 + 1e10） - 1e10的结果会是0.0。

浮点加法满足单调性，如果a>=b，对于任何的x值，都有x+a>=x+b。

浮点乘法不具备结合性，（1e20 × 1e20）× 1e-20的值为正无穷，然而 1e20 × （1e20 × 1e-20）的值为1e20。

浮点乘法不具备分配律，1e20 ×（1e20-1e20） 的值为0.0，然而1e20 × 1e20 - 1e20 × 1e20会得到NaN。

### 强制类型转换

- int转换成float，数字不会溢出，但是可能被舍入。
- int或float转换成double，因为double有比这两者都来得更大的范围，和更高的精度，所以能够保留精确的数值。
- double转成float，范围会变小，有可能得到值正负无穷。由于精度也变小了，所以可能被舍入。
- float或double转成int，值将会像零舍入。例如：1.999会变成1，-1.999会变成-1。值有可能溢出。**C语言标准没有对这种情况制定固定的结果。**

