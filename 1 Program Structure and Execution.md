# 1.2 目标程序被其他程序转为不同形式

## 编译系统做的事

以hello.c为例子，编译器负责将源文件转为可执行的目标文件，按照如下步骤执行：

1. 预处理：修改源文件的头部声明，即所有#字符开头的行，读取stdio.h的内容直接嵌入到源文件，产生以.i为后缀的文件。
2. 编译步骤：编译器将hello.c转为hello.s，包含了汇编语言程序。
3. 汇编阶段：assembler将hello.s转为机器指令，打包它们存储为hello.o文件，包含了17个字节。
4. 连接阶段：程序调用了printf函数，它位于预编译对象文件print.o里，后者需要和hello.o进行合并，连接器负责处理这个合并产生hello可执行对象文件。

# 1.4 处理器读取并翻译存储在内存的指令

## 1.4.1 系统硬件组织

### 总线

总线负责在各个组成之间进行字节的传输固定大小的字节块words，word里字节数目随系统不同而不同，常见32位和64位。

### 输入输出设备

是系统和外部连接桥梁，有键盘鼠标显示器和磁盘设备，每个设备通过controller或者adapter连接总线。controller是设备本身或系统主印刷电路板（通常称为主板）上的芯片组。 适配器是插入主板插槽的卡。

### 主存

在处理器执行时，主存用于存储程序和数据的临时存储设备。一般主存由大量的DRAM芯片组组成，以线性字节进行排列，每个组成程序的机器指令都由大量比特组成。

### 处理器

是翻译执行存储在主存的指令引擎，核心是一个word大小的存储设备，被称为PC，即程序计数器，任何时候PC都指向主存的某个机器指令。通过读取PC指向的指令比特并执行，进行简单的操作，然后更新PC到下一个指令直到断电。

## 1.4.2 运行hello程序

一开始，shell程序执行自身指令，等待用户输入，随着输入./hello，shell程序会读取每个字符到寄存器并存储进主存，如图1.5所示。

当输入回车后，shell程序会加载hello文件，执行指令序列，复制代码和数据从磁盘到主存里。

使用DMA技术，数据可直接从磁盘到主存，如图1.6所示。

一旦hello对象文件的数据和代码加载到主存，处理器就开始执行hello的机器指令，这些指令复制hello,world\n字符串从主存到寄存器，再到显示设备，如图1.7所示。

# 1.5 缓存

程序加载需要从磁盘复制到主存，指令需要从磁盘到主存再到处理器，输出还需要到显示设备，可见复制是很重的负担，降低了程序的运行速度。

为了解决不同组建处理速度的问题，缓存作为临时区域，以更快的速度用于存储处理器未来处理的数据，它位于处理器和主存之间。图1.8显示了系统的缓存，L1和L2缓存通过SRAM（静态随机访问内存）实现。通过设置缓存来保存可能经常访问的数据，可以使用快速缓存执行大多数内存操作。

# 1.7 操作系统管理硬件

## 1.7.1 进程

当hello运行在系统里时，操作系统提供了一个假象，即当前系统只有一个程序在运行，程序的代码和数据似乎是系统主存的唯一实体，这得益于进程的概念。

进程是正在运行程序的抽象，多核处理器可以同时执行几个程序，操作系统通过上下文切换进行程序的交替执行，出于简化，下文讨论的系统只有一个处理器。

操作系统追踪进程所有的状态信息，即上下文，包括PC，寄存器文件，主存内容。进程切换就是恢复新进程状态信息并将处理器控制器给新进程的过程。

以hello为例子：一开始shell单独运行，等待用户输入，输入./hello后，shell将我们的请求带入调用系统调用，操作系统保存shell上下文，创建新的hello进程和它的上下文，将控制权给hello进程。在hello终止后，操作系统将shell程序恢复上下文，将控制权给shell进程，等待用户输入。

如图1.12所示，从一个进程到另一个进程到切换由kernel实现，kernel是操作系统的部分代码，驻留在主存里。当某个进程需要操作系统协助例如进行读写文件时，会执行系统调用指令，将控制权交给kernel，kernel处理请求操作并返回给应用程序。kernel本质上是代码和数据结构集合，由系统使用去管理所有进程。

## 1.7.2 线程

现代操作系统里，一个进程由多个执行单元称为线程组成，每个都运行在进程的上下文里并共享相同代码和变量。多线程是一种在多处理器情况下让程序运行地更快的手段。

## 1.7.3 虚拟内存

虚拟内存为每个程序提供了独占主存的假象，每个进程对内存都有一致的视角，即虚拟内存。图1.13给出了linux进程的虚拟内存图。最顶端地区区域用于操作系统的代码和数据，第二层地址保留了用户进程的代码和数据。

每个进程的虚拟地址空间由以下区域组成（从底向上）：

1. 程序代码和数据：所有进程都在相同地址（0地址）开始存储代码，然后是数据。
2. 堆：第二层，和程序代码和数据固定大小不同的是，一旦进程开始运行，堆的大小动态改变的，可通过malloc和free改变。
3. 共享库：第三层，大致是地址空间中间就是C标准库和数学库的代码和数据。
4. 栈：用户细腻地址顶端是用户栈，编译器使用栈进行函数调用，栈会在程序运行的时候动态增加减少，调用函数，栈就变大，返回函数，栈就变小。
5. kernel虚拟内存：最顶端的地址空间用于kernel，程序无法直接读取这边的数据调用函数，必须通过调用kernel完成这些操作。

## 1.7.4 文件

每个输入输出设备都被视为文件，系统所有的输入输出都通过读写文件运行，读写文件必须使用一系列系统调用。

# 1.8 使用网络和其他系统通信

这里给了一个使用telnet远程运行hello的例子。

1. 输入hello字符串到telnet客户端，输入回车，客户端发送字符串给telnet服务器。
2. 服务器从网络接受字符串，传递给远程的shell程序。
3. 远程的shell程序运行hello，并传递结果给telnet服务器。
4. 最后telnet服务器转发输出字符串给telnet客户端，输出结果。

# 1.9 重要的主题

## 1.9.1 阿姆达尔定律

使用阿姆达尔定律来说明存储系统性能分析模型。

## 1.9.2 并发和并行

并发指代多个同时的活动。

### 线程级别并发

可设计多程序同时执行，完成并发。在一台计算机上模拟并发，传统的并发执行是通过不断切换进程实现的。

通过多处理器构建多处理器系统，多处理器随着多核和超线程的出现变得流行起来。多核处理器有好几个CPU，称为核，图1.17给出了多核处理器的图，图里4个CPU核，每个都有L1和L2缓存，L1缓存分为2部分，一个存储最近使用的指令，一个存储数据，L3缓存在所有核里共享。

超线程，有时被称为同时的多线程，是一种允许一个CPU执行多个控制流的技术，它涉及CPU硬件的多个备份如程序计数器和寄存器。超线程处理器逐周期会决定哪些线程执行，这可以让CPU更好利用资源，例如英特尔i7处理器可以在一个核上执行两个线程。

### 指令级并行

现代处理器可以一次执行多条指令，这种特性称为指令级并行性。老的8086需要3-10个时钟周期执行一条指令，现在的处理器每个时钟周期可以执行2-4条指令。每个周期可以维持超过1条指令的执行速率的处理器称为超标量处理器。大多数现代处理器都支持超标量操作。

### 单指令多数据并行（SIMD）

当代的计算机已经允许单个指令同时进行多个操作，例如AMD和Intel可以同时进行8对浮点数运算。提供这些 SIMD 指令主要是为了加快处理图像、声音和视频数据的应用程序的速度。

## 1.9.3 计算机系统抽象的重要性

计算机系统的主要主题是提供不同等级的抽象以隐藏实际实现的复杂性。

如图1.18所示，处理器端，指令集架构提供了处理器硬件的抽象，通过这种抽象，机器代码程序的行为就像是在一次只执行一条指令的过程上执行的一样。底层硬件要复杂得多，并行执行多条指令，但始终以与简单、顺序模型一致的方式执行。

在操作系统端，引入文件作为输入输出的抽象，虚拟内存作为程序内存的抽象和进程作为运行程序的抽象。我们添加了一个虚拟机的抽象，即抽象了整个计算机系统，包括OS，处理器和程序。